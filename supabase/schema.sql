create extension if not exists "pgcrypto";

create table if not exists public.roles (
  id smallint primary key,
  name text unique not null
);
insert into public.roles (id, name) values (1,'admin'), (2,'user') on conflict do nothing;

create table if not exists public.profiles (
  user_id uuid primary key references auth.users(id) on delete cascade,
  role_id smallint not null references public.roles(id),
  created_at timestamptz not null default now()
);

create table if not exists public.user_directory (
  user_id uuid primary key references auth.users(id) on delete cascade,
  email text not null,
  username text,
  created_at timestamptz not null default now()
);

create unique index if not exists user_directory_username_unique on public.user_directory (lower(username)) where username is not null;
create or replace function public.handle_new_user()
returns trigger as $$
begin
  insert into public.profiles (user_id, role_id) values (new.id, 2) on conflict do nothing;
  insert into public.user_directory (user_id, email, username)
  values (new.id, new.email, nullif(trim(lower(new.raw_user_meta_data->>'username')), ''))
  on conflict do nothing;
  return new;
end;
$$ language plpgsql security definer;

drop trigger if exists on_auth_user_created on auth.users;
create trigger on_auth_user_created after insert on auth.users
for each row execute procedure public.handle_new_user();

create table if not exists public.services (
  id smallint generated by default as identity primary key,
  name text unique not null
);
create table if not exists public.vehicles (
  id smallint generated by default as identity primary key,
  name text unique not null
);
create table if not exists public.payments (
  id smallint generated by default as identity primary key,
  name text unique not null
);


-- Collection / payment status lookup
create table if not exists public.collection (
  id smallint generated by default as identity primary key,
  name text not null unique
);

-- Seed values
insert into public.collection (name) values
  ('Non-invoiced'),
  ('Invoiced'),
  ('Under-collection'),
  ('Collected')
on conflict (name) do nothing;


insert into public.services(name) values ('Tow Truck'),('Limousine'),('Car Rental') on conflict do nothing;
insert into public.vehicles(name) values ('Truck 1'),('Truck 2'),('Car 1'),('Car 2') on conflict do nothing;
insert into public.payments(name) values ('Cash'),('Bank Transfer') on conflict do nothing;

create table if not exists public.customers (
  id uuid primary key default gen_random_uuid(),
  name text not null,
  contact_name text,
  telephone text,
  email text,
  price_list_copy_url text,
  commercial_register_no text,
  tax_id_no text,
  commercial_register_copy_url text,
  tax_id_copy_url text,
  created_by uuid references auth.users(id),
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

alter table public.customers
  add constraint customer_email_format check (email is null or email ~* '^[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,}$');
alter table public.customers
  add constraint customer_phone_len check (telephone is null or length(telephone) between 7 and 20);

alter table public.customers
  add constraint cr_max_6_digits check (commercial_register_no is null or (commercial_register_no ~ '^[0-9]{1,6}$'));
alter table public.customers
  add constraint tax_id_format check (tax_id_no is null or (tax_id_no ~ '^[0-9]{3}-[0-9]{3}-[0-9]{3}$'));

create table if not exists public.trips (
  id bigint generated by default as identity primary key,
  trip_no text unique,
  trip_date date not null,
  customer_id uuid not null references public.customers(id),
  service_id smallint not null references public.services(id),
  vehicle_id smallint not null references public.vehicles(id),
  pickup_location text not null,
  dropoff_location text not null,
  price_per_trip integer not null,
  payment_id smallint not null references public.payments(id),
  pickup_photos jsonb not null default '[]'::jsonb,
  dropoff_photos jsonb not null default '[]'::jsonb,
  status text not null default 'pending' check (status in ('pending','approved')),
  created_by uuid not null references auth.users(id),
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

alter table public.trips add constraint price_digits check (price_per_trip between 100 and 99999);

create or replace function public.set_updated_at()
returns trigger as $$
begin
  new.updated_at = now();
  return new;
end;
$$ language plpgsql;

drop trigger if exists trg_customers_updated on public.customers;
create trigger trg_customers_updated before update on public.customers
for each row execute procedure public.set_updated_at();

drop trigger if exists trg_trips_updated on public.trips;
create trigger trg_trips_updated before update on public.trips
for each row execute procedure public.set_updated_at();

-- RLS
alter table public.roles enable row level security;
alter table public.profiles enable row level security;
alter table public.user_directory enable row level security;
alter table public.services enable row level security;
alter table public.vehicles enable row level security;
alter table public.payments enable row level security;
alter table public.customers enable row level security;
alter table public.trips enable row level security;

create or replace function public.is_admin(uid uuid)
returns boolean as $$
  select exists (
    select 1 from public.profiles p join public.roles r on r.id = p.role_id
    where p.user_id = uid and r.name = 'admin'
  );
$$ language sql stable security definer;

create policy "user_directory_admin_read" on public.user_directory for select using (public.is_admin(auth.uid()));
create policy "profiles_read_own_or_admin" on public.profiles for select using (user_id = auth.uid() or public.is_admin(auth.uid()));
create policy "profiles_admin_update" on public.profiles for update using (public.is_admin(auth.uid())) with check (public.is_admin(auth.uid()));

create policy "masters_read_services" on public.services for select using (auth.uid() is not null);
create policy "masters_read_vehicles" on public.vehicles for select using (auth.uid() is not null);
create policy "masters_read_payments" on public.payments for select using (auth.uid() is not null);
create policy "masters_admin_write_services" on public.services for all using (public.is_admin(auth.uid())) with check (public.is_admin(auth.uid()));
create policy "masters_admin_write_vehicles" on public.vehicles for all using (public.is_admin(auth.uid())) with check (public.is_admin(auth.uid()));
create policy "masters_admin_write_payments" on public.payments for all using (public.is_admin(auth.uid())) with check (public.is_admin(auth.uid()));

create policy "customers_admin_all" on public.customers for all using (public.is_admin(auth.uid())) with check (public.is_admin(auth.uid()));
create policy "customers_user_read" on public.customers for select using (auth.uid() is not null);

create policy "trips_read_logged_in" on public.trips for select using (auth.uid() is not null);
create policy "trips_insert_logged_in" on public.trips for insert with check (auth.uid() is not null and created_by = auth.uid());
create policy "trips_user_update_pending_own" on public.trips for update
  using (auth.uid() is not null and created_by = auth.uid() and status = 'pending')
  with check (created_by = auth.uid() and status = 'pending');
create policy "trips_admin_all" on public.trips for all using (public.is_admin(auth.uid())) with check (public.is_admin(auth.uid()));


-- Default collection status = Non-invoiced
alter table public.trips
  alter column collection_id set default (
    select id from public.collection where name = 'Non-invoiced'
  );

create index if not exists trips_collection_id_idx on public.trips (collection_id);



-- Trip number generator: YY#### based on trip_date year with per-year serial
create table if not exists public.trip_year_counters (
  year smallint primary key,
  last_serial integer not null
);

create or replace function public.trips_set_trip_no()
returns trigger
language plpgsql
as $$
declare
  yy text;
  y smallint;
  next_serial integer;
begin
  -- Only generate if not provided
  if new.trip_no is null or new.trip_no = '' then
    y := extract(year from new.trip_date)::int;
    yy := to_char(new.trip_date, 'YY');

    -- Ensure counter row exists, lock it, then increment
    insert into public.trip_year_counters(year, last_serial)
      values (y, 0)
      on conflict (year) do nothing;

    select last_serial into next_serial
      from public.trip_year_counters
      where year = y
      for update;

    next_serial := next_serial + 1;

    update public.trip_year_counters
      set last_serial = next_serial
      where year = y;

    new.trip_no := yy || lpad(next_serial::text, 4, '0');
  end if;

  return new;
end;
$$;

drop trigger if exists trg_trips_set_trip_no on public.trips;

create trigger trg_trips_set_trip_no
before insert on public.trips
for each row
execute function public.trips_set_trip_no();


-- Backfill trip_no for existing rows (run once after deploying, if needed)
-- This will generate sequential numbers by trip_date per year.
-- Note: if you already have trip_no values, this will skip them.


-- RPC: resolve email from username for login (callable by anon)
create or replace function public.email_for_username(p_username text)
returns text
language sql
security definer
stable
as $$
  select email
  from public.user_directory
  where lower(username) = lower(p_username)
  limit 1;
$$;

revoke all on function public.email_for_username(text) from public;
grant execute on function public.email_for_username(text) to anon, authenticated;

