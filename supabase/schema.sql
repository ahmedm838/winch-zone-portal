create extension if not exists "pgcrypto";

create table if not exists public.roles (
  id smallint primary key,
  name text unique not null
);
insert into public.roles (id, name) values (1,'admin'), (2,'user') on conflict do nothing;

create table if not exists public.profiles (
  user_id uuid primary key references auth.users(id) on delete cascade,
  role_id smallint not null references public.roles(id),
  created_at timestamptz not null default now()
);

create table if not exists public.user_directory (
  user_id uuid primary key references auth.users(id) on delete cascade,
  email text not null,
  created_at timestamptz not null default now()
);

create or replace function public.handle_new_user()
returns trigger as $$
begin
  insert into public.profiles (user_id, role_id) values (new.id, 2) on conflict do nothing;
  insert into public.user_directory (user_id, email) values (new.id, new.email) on conflict do nothing;
  return new;
end;
$$ language plpgsql security definer;

drop trigger if exists on_auth_user_created on auth.users;
create trigger on_auth_user_created after insert on auth.users
for each row execute procedure public.handle_new_user();

create table if not exists public.services (
  id smallint generated by default as identity primary key,
  name text unique not null
);
create table if not exists public.vehicles (
  id smallint generated by default as identity primary key,
  name text unique not null
);
create table if not exists public.payments (
  id smallint generated by default as identity primary key,
  name text unique not null
);

insert into public.services(name) values ('Tow Truck'),('Limousine'),('Car Rental') on conflict do nothing;
insert into public.vehicles(name) values ('Truck 1'),('Truck 2'),('Car 1'),('Car 2') on conflict do nothing;
insert into public.payments(name) values ('Cash'),('Bank Transfer') on conflict do nothing;

create table if not exists public.customers (
  id uuid primary key default gen_random_uuid(),
  name text not null,
  commercial_register_no text,
  tax_id_no text,
  commercial_register_copy_url text,
  tax_id_copy_url text,
  created_by uuid references auth.users(id),
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

alter table public.customers
  add constraint cr_max_6_digits check (commercial_register_no is null or (commercial_register_no ~ '^[0-9]{1,6}$'));
alter table public.customers
  add constraint tax_id_format check (tax_id_no is null or (tax_id_no ~ '^[0-9]{3}-[0-9]{3}-[0-9]{3}$'));

create table if not exists public.trips (
  id bigint generated by default as identity primary key,
  trip_date date not null,
  customer_id uuid not null references public.customers(id),
  service_id smallint not null references public.services(id),
  vehicle_id smallint not null references public.vehicles(id),
  pickup_location text not null,
  dropoff_location text not null,
  price_per_trip integer not null,
  payment_id smallint not null references public.payments(id),
  pickup_photos jsonb not null default '[]'::jsonb,
  dropoff_photos jsonb not null default '[]'::jsonb,
  status text not null default 'pending' check (status in ('pending','approved')),
  created_by uuid not null references auth.users(id),
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

alter table public.trips add constraint price_digits check (price_per_trip between 100 and 99999);

create or replace function public.set_updated_at()
returns trigger as $$
begin
  new.updated_at = now();
  return new;
end;
$$ language plpgsql;

drop trigger if exists trg_customers_updated on public.customers;
create trigger trg_customers_updated before update on public.customers
for each row execute procedure public.set_updated_at();

drop trigger if exists trg_trips_updated on public.trips;
create trigger trg_trips_updated before update on public.trips
for each row execute procedure public.set_updated_at();

-- RLS
alter table public.roles enable row level security;
alter table public.profiles enable row level security;
alter table public.user_directory enable row level security;
alter table public.services enable row level security;
alter table public.vehicles enable row level security;
alter table public.payments enable row level security;
alter table public.customers enable row level security;
alter table public.trips enable row level security;

create or replace function public.is_admin(uid uuid)
returns boolean as $$
  select exists (
    select 1 from public.profiles p join public.roles r on r.id = p.role_id
    where p.user_id = uid and r.name = 'admin'
  );
$$ language sql stable security definer;

create policy "user_directory_admin_read" on public.user_directory for select using (public.is_admin(auth.uid()));
create policy "profiles_read_own_or_admin" on public.profiles for select using (user_id = auth.uid() or public.is_admin(auth.uid()));
create policy "profiles_admin_update" on public.profiles for update using (public.is_admin(auth.uid())) with check (public.is_admin(auth.uid()));

create policy "masters_read_services" on public.services for select using (auth.uid() is not null);
create policy "masters_read_vehicles" on public.vehicles for select using (auth.uid() is not null);
create policy "masters_read_payments" on public.payments for select using (auth.uid() is not null);
create policy "masters_admin_write_services" on public.services for all using (public.is_admin(auth.uid())) with check (public.is_admin(auth.uid()));
create policy "masters_admin_write_vehicles" on public.vehicles for all using (public.is_admin(auth.uid())) with check (public.is_admin(auth.uid()));
create policy "masters_admin_write_payments" on public.payments for all using (public.is_admin(auth.uid())) with check (public.is_admin(auth.uid()));

create policy "customers_admin_all" on public.customers for all using (public.is_admin(auth.uid())) with check (public.is_admin(auth.uid()));
create policy "customers_user_read" on public.customers for select using (auth.uid() is not null);

create policy "trips_read_logged_in" on public.trips for select using (auth.uid() is not null);
create policy "trips_insert_logged_in" on public.trips for insert with check (auth.uid() is not null and created_by = auth.uid());
create policy "trips_user_update_pending_own" on public.trips for update
  using (auth.uid() is not null and created_by = auth.uid() and status = 'pending')
  with check (created_by = auth.uid() and status = 'pending');
create policy "trips_admin_all" on public.trips for all using (public.is_admin(auth.uid())) with check (public.is_admin(auth.uid()));
